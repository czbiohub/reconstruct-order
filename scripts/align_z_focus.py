import os
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from waveorder2reconorder import read_img
from dynamorph_seg_map import get_sms_im_name

def brenner_gradient(im):
    assert len(im.shape) == 2, 'Input image must be 2D'
    return np.mean((im[:-2, :] - im[2:, :]) ** 2)

if __name__ == '__main__':
    # input_dir = '/CompMicro/projects/A549/20210209_Falcon_3D_uPTI_A549_RSV'
    # input_dir = '/CompMicro/projects/A549/2021_02_25_40X_04NA_A549_tif'
    # input_dir = '/CompMicro/projects/HEK/2021_04_20_HEK_OC43_63x_04NA_Widefield_tif/2021_04_20_HEK_OC43_widefield'
    # input_dir = '/CompMicro/projects/HEK/2021_05_12_HEK_RSV_20x_055na_TimeLapse_tif'
    # input_dir = '/CompMicro/projects/HEK/2021_06_04_HEK_Nuclei_DAPI_tif'
    # input_dir = '/CompMicro/projects/HEK/2021_08_25_LiveHEK_63x_09NA_StainedOrgs_tif'
    input_dir = '/CompMicro/projects/HEK/2021_07_29_LiveHEK_NoPerf_63x_09NA_tif'
    output_dir = os.path.join(input_dir, '_'.join([os.path.basename(input_dir), 'registered']))
    # ref_chans = ['Phase3D', 'MTub']
    # ref_chans = ['Phase3D', 'DAPI']
    # ref_chans = ['Phase3D', 'GFP']
    ref_chans = ['Phase3D']
    # pol_chans = ['Phase3D']
    pol_chans = ['Phase3D', 'Retardance']
    # pol_chans = ['Phase3D', 'Retardance', 'GFP']
    # fluor_chans = ['DAPI', 'RSV']
    # fluor_chans = ['GFP']
    # fluor_chans = ['MTub', 'DAPI', 'Golgi', 'ER']
    # fluor_chans = ['DAPI']
    # fluor_chans = ['DRAQ5']
    # chan_groups = [pol_chans, fluor_chans]
    chan_groups = [pol_chans]
    # conditions = [s for s in get_sub_dirs(input_dir) if s.startswith('Well')]
    # conditions_new = ['Mock_rep0', 'Mock_rep1', 'MOI0.25_rep0', 'MOI0.25_rep1', 'MOI1_rep0', 'MOI1_rep1', 'MOI2_rep0', 'MOI2_rep1']
    # conditions = [s for s in get_sub_dirs(input_dir)]
    # conditions = ['HEK_Phase3D_Padded']
    # conditions = [x for x in get_sub_dirs(input_dir) if 'Pos' in x]
    # conditions = ['Timelapse']
    conditions = ['']
    conditions_new = conditions
    # conditions_new = ['Mock', 'MOI_100', 'MOI_1', 'MOI_0.5', 'MOI_0.1']
    assert len(conditions) == len(conditions_new), 'length mismatch for "conditions" and "conditions_new"'
    condi_mapping = dict(zip(conditions, conditions_new))
    # conditions = ['RSV_IFNL_24']
    # z_range = [2, 14]
    meta_master = pd.DataFrame()
    for condition in conditions:
        print('processing condition {}...'.format(condition))
        # Load frames metadata and determine indices if exists
        fmeta_path = os.path.join(input_dir, condition, 'frames_meta.csv')
        if os.path.isfile(fmeta_path):
            frames_meta = pd.read_csv(fmeta_path, index_col=0)
        else:
            raise FileNotFoundError('"frames_meta.csv" generated by microDL is required')

        # print(frames_meta['pos_idx'].unique())
        dst_dir = os.path.join(output_dir, condi_mapping[condition])
        os.makedirs(dst_dir, exist_ok=True)
        pos_ids = frames_meta['pos_idx'].unique()
        pos_ids.sort()
        src_dir = os.path.join(input_dir, condition)
        pol_focus = []
        flour_focus = []
        frames_meta['condition'] = condi_mapping[condition]
        # loop through reference stack at each position
        for pos_idx in pos_ids:
            frames_meta_p = frames_meta[frames_meta['pos_idx'] == pos_idx]
            t_ids = frames_meta_p['time_idx'].unique()
            t_ids.sort()
            for t_idx in t_ids:
                frames_meta_pt = frames_meta_p[frames_meta_p['time_idx'] == t_idx]
                focus_idx = None
                for chans in chan_groups:
                    for chan in chans:
                        print(
                            'Processing position {}, time {}, channel {}...'.format(pos_idx, t_idx, chan))
                        frames_meta_ptc = frames_meta_pt[frames_meta_pt['channel_name'] == chan]
                        z_ids = frames_meta_ptc['slice_idx'].unique()
                        z_ids.sort()
                        if chan in ref_chans:
                            focus_scores = []
                            for z_idx in z_ids:
                                frames_meta_ptcz = frames_meta_ptc[frames_meta_ptc['slice_idx'] == z_idx]
                                im_path = os.path.join(frames_meta_ptcz['dir_name'].values[0], frames_meta_ptcz['file_name'].values[0])
                                focus_score = brenner_gradient(read_img(im_path))
                                focus_scores.append(focus_score)
                            if chan == 'Brightfield':
                                focus_idx = z_ids[np.argmin(focus_scores)]
                            else:
                                focus_idx = z_ids[np.argmax(focus_scores)]
                        else:
                            assert focus_idx is not None, 'reference channel must be the first channel in the channel list'
                        frames_meta.loc[(frames_meta['pos_idx'] == pos_idx) &
                                    (frames_meta_p['time_idx'] == t_idx) &
                                    (frames_meta_pt['channel_name'] == chan), 'focus_idx'] = focus_idx
                        frames_meta.loc[(frames_meta['pos_idx'] == pos_idx) &
                                        (frames_meta_p['time_idx'] == t_idx) &
                                        (frames_meta_pt['channel_name'] == chan), 'focus_score'] = focus_scores
        frames_meta['dst_dir'] = dst_dir
        meta_master = meta_master.append(frames_meta)
        # plot focus scores
        # for chan in ref_chans:
        #     frames_meta_c = frames_meta[frames_meta['channel_name'] == chan]
        #     ax = sns.lineplot(data=frames_meta_c, x='slice_idx', y='focus_score', hue='time_idx')
        #     ax.figure.savefig(os.path.join(input_dir, 'focus_scores_{}_{}.png'.format(condition, chan)))
        #     plt.close()
    focus_offset = meta_master['focus_idx'] - int(meta_master['focus_idx'].median())
    z_ids_new = np.arange(z_ids[0] - focus_offset.min(), z_ids[-1] - focus_offset.max() + 1)
    meta_master['slice_idx_new'] = meta_master['slice_idx'] - focus_offset
    meta_master['slice_idx_new'] = meta_master['slice_idx_new'].astype('int64')
    meta_master = meta_master.loc[meta_master['slice_idx_new'].isin(z_ids_new), :]
    meta_master.reset_index(drop=True, inplace=True)
    for row_idx in list(meta_master.index):
        meta_row = meta_master.loc[row_idx]
        im_src_path = os.path.join(meta_row['dir_name'],
                                   meta_row['file_name'])
        im_name_dst = get_sms_im_name(
            time_idx=meta_row['time_idx'],
            channel_name=meta_row['channel_name'],
            slice_idx=meta_row['slice_idx_new'],
            pos_idx=meta_row['pos_idx'],
            ext='.tif',
        )
        os.link(im_src_path,
             os.path.join(meta_row['dst_dir'], im_name_dst))
    meta_master.to_csv(os.path.join(input_dir, 'frames_meta.csv'), sep=',')
